<?php

namespace Honeybee\FrameworkBinding\Agavi\Routing;

use AgaviContext;
use AgaviExecutionContainer;
use AgaviRoutingCallback;
use Negotiation\FormatNegotiator;

/**
 * Inspects the Accept HTTP header and sets the output_type according to
 * the 'acceptable_media_types' parameter of output types. That parameter
 * defines whether an output type feels responsible for that incoming media
 * type. When a media type has priority in the Accept header the output type
 * that feels responsible for that media type is set.
 * The order of output types in the output_types xml file is important for
 * equally prioritized Accept header values!
 */
class NegotiateOutputTypeRoutingCallback extends AgaviRoutingCallback
{
    /**
     * @var Honeybee\FrameworkBinding\Agavi\Controller\HoneybeeAgaviController
     */
    protected $controller = null;

    /**
     * @param AgaviContext $context
     * @param array $route
     */
    public function initialize(AgaviContext $context, array &$route)
    {
        parent::initialize($context, $route);

        $this->controller = $this->context->getController();
    }

    /**
     * Gets executed when the route of this callback matched.
     *
     * @param array The parameters generated by this route.
     * @param AgaviExecutionContainer The original execution container.
     *
     * @return bool false as routes with this callback should never match.
     *
     * @SuppressWarnings(PHPMD.UnusedFormalParameter)
     */
    public function onMatched(array &$parameters, AgaviExecutionContainer $container)
    {
        $request_data = $this->context->getRequest()->getRequestData();

        // allow the route to match even though the Accept header is missing
        // we don't set a default output type, as the application has one
        if (!$request_data->hasHeader('Accept')) {
            return true;
        }

        // Example value: text/html;q=0.91,application/xhtml+xml;q=0.92,application/xml;q=0.9,*/*;q=0.8
        // ,application/json;odata=fullmetadata;q=0.98,application/vnd.amundsen.collection+json,foo/bar
        $accept_header_value = $request_data->getHeader('Accept');

        // all known/configured output types
        $all_output_types = $this->controller->getOutputTypes();

        // all output types that define acceptable media types
        $supported_output_types = array();
        foreach ($all_output_types as $output_type) {
            $media_types = $output_type->getParameter('acceptable_media_types', array());
            if (is_string($media_types)) {
                $media_types = array($media_types);
            }
            if (!empty($media_types)) {
                $supported_output_types[$output_type->getName()] = $media_types;
            }
        }

        $negotiator = new FormatNegotiator();

        // get a prioritized list of all media types (over all output types)
        $all_supported_media_types = array();
        foreach ($supported_output_types as $output_type => $media_types) {
            foreach ($media_types as $media_type) {
                $all_supported_media_types[] = $media_type;
            }
            // register all known supported media types
            $negotiator->registerFormat($output_type, $media_types, $override = true);
        }

        $matching_output_type = $negotiator->getBestFormat($accept_header_value, $all_supported_media_types);

        // TODO the negotiator v1 has predefined stuff we don't want; perhaps changing to v2 helps
        if ($matching_output_type === 'txt') {
            $matching_output_type = 'text';
        }

        // set the current output type to the matching one
        if ($matching_output_type !== null) {
            $new_output_type = $this->controller->getOutputType($matching_output_type);
            $container->setOutputType($new_output_type);
            return true;
        }

        // media types did not match, but we want a default output type to be set
        if ($matching_output_type === null && $this->hasParameter('default_output_type')) {
            $default_output_type = $this->controller->getOutputType($this->getParameter('default_output_type'));
            $container->setOutputType($default_output_type);
            return true;
        }

        /*
         * no matching output type was found for the given Accept header
         * and no default output type was defined => return a 406 http error
         */

        sort($all_supported_media_types); // sort alphabetically to ease reading

        $response_content = <<<EOC
# 406 Not Acceptable

The Accept header of the request does not specify a media type that
is currently acceptable. The following media types are supported instead:


EOC;

        foreach ($all_supported_media_types as $media_type) {
            $response_content .= '- ' . $media_type . PHP_EOL;
        }

        $response = $this->getContext()->createInstanceFor('response');
        $response->setContent($response_content);
        $response->setContentType('text/x-markdown; charset=UTF-8');
        $response->setHttpStatusCode('406');

        return $response;
    }

    /**
     * Gets executed when the route of this callback did not match.
     *
     * @param AgaviExecutionContainer The original execution container.
     *
     * @SuppressWarnings(PHPMD.UnusedFormalParameter)
     */
    public function onNotMatched(AgaviExecutionContainer $container)
    {
        return;
    }

    /**
     * Gets executed when the route of this callback is about to be reverse
     * generated into an URL.
     *
     * @param array The default parameters stored in the route.
     * @param array The parameters the user supplied to AgaviRouting::gen().
     * @param array The options the user supplied to AgaviRouting::gen().
     *
     * @return bool false as this route part should not be generated.
     *
     * @SuppressWarnings(PHPMD.UnusedFormalParameter)
     */
    public function onGenerate(array $default_parameters, array &$user_parameters, array &$user_options)
    {
        return false;
    }

    /**
     * Parsing of accept header values.
     *
     * @return array media type strings
     */
    public static function parseAcceptString($accept_header_value)
    {
        $types = array();

        $regex = '#(^|\s*,\s*)((\*/\*|[^/]+/\*|[^/]+/[^;,$]+)(\s*;\s*(?!q=)[^=]+=[^;,$]+)*)' .
            '\s*(;\s*q\s*=\s*(1(\.0{0,3})?|0(\.[0-9]{0,3})))?#i';

        if (preg_match_all('', $accept_header_value, $matches)) {
            foreach ($matches[6] as &$quality) {
                if ($quality === '') {
                    $quality = '1';
                }
            }

            $types = array_combine($matches[2], $matches[6]);

            arsort($types, SORT_NUMERIC);
        }

        return array_keys($types);
    }
}
